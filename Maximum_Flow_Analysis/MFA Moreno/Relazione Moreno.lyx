#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{tikz}
\usepackage{braket}
\usepackage{qcircuit}
\usepackage{url}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle true
\pdf_quoted_options "hyperfootnotes=true"
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Quantum Max Flow Analysis
\end_layout

\begin_layout Author
Moreno Giussani
\end_layout

\begin_layout Abstract
This document will describe the analysis I have performed in the last months
 about the quantum implementation of the Max Flow algorithm.
 The max flow problem involves finding a feasible flow through a single-source,
 single-sink flow network that is maximum.
 I have been working for finding a practical solution to this problem using
 a quantum algorithm which could be at least as efficient as a classical
 one in a general case, without succeding in it.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Before considering the algorithm, I have tried to understand most of the
 concepts which lies behind a quantum algorithm.
\end_layout

\begin_layout Standard
For what regards quantum computing, the standard model of computation is
 the quantum circuit.
 A quantum circuit is a scheme composed of some elementary blocks, which
 are qubits and quantum logic gates.
 Rows of this scheme represents qubits, while in columns are inserted quantum
 logic gates.
\end_layout

\begin_layout Standard
Sometimes, the tensor network model is used, especially in quantum physics
 papers.
\end_layout

\begin_layout Subsection
Qubit
\end_layout

\begin_layout Standard
Qubits are the quantum equivalent of bits.
 They are usually represented using the bra-ket notation.
 A single qubit 
\begin_inset Formula $\Ket{Q_{0}}$
\end_inset

is usually described by a 2-dimensional column vector (Ket notation) which
 is a specific linear combination of its orthonormal bases 
\begin_inset Formula $\Ket{0}=\left[\begin{array}{c}
1\\
0
\end{array}\right]$
\end_inset

 and 
\begin_inset Formula $\Ket{1}=\left[\begin{array}{c}
0\\
1
\end{array}\right]$
\end_inset

.
 When the qubit is measured (an equivalent operation of reading a bit value
 in classical computing), its value collapses to either 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Ket{0}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 or 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Ket{1}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 (their orthonormal bases).
\end_layout

\begin_layout Standard
Suppose 
\begin_inset Formula $\Ket{Q_{0}}$
\end_inset

is defined as 
\begin_inset Formula 
\[
\Ket{Q_{0}}=\alpha\Ket{0}+\beta\Ket{1}\;\alpha\in\mathbb{C},\beta\in\mathbb{C}
\]

\end_inset

Then 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\beta$
\end_inset

 must respect the rule 
\begin_inset Formula $|\alpha|^{2}+|\beta|^{2}=1$
\end_inset

 , because 
\begin_inset Formula $|\alpha|^{2}$
\end_inset

 represents the probability that a measurement outputs 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Ket{0}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 and 
\begin_inset Formula $|\beta|^{2}$
\end_inset

 represents the probability that a measurement outputs 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Ket{1}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
.
 During the computation the qubit can assume an 
\begin_inset Quotes eld
\end_inset

overlapped
\begin_inset Quotes erd
\end_inset

 state (both state 0 and state 1), but when measured, its expressivity power
 reduces to a classical bit.
 When both 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\beta$
\end_inset

 are different from 0 ,
\begin_inset Formula $Q_{0}$
\end_inset

 is said to be in superposition.
\end_layout

\begin_layout Standard
Qubits have also another interesting property: they cannot be copied.
 There is no way to create an identical copy of an arbitrary unknown quantum
 state (
\shape italic
no cloning theorem
\shape default
).
\end_layout

\begin_layout Standard
Now, things get a bit tricky when considering a N-qubit quantum computer.
 If there are two or more qubits, their representation is made as the Kronecker
 product of all of the qbits, so they often cannot be considered as separated
 qubits.
 Suppose to have a 3-qubit quantum computer which uses qubits 
\begin_inset Formula $Q_{a},Q_{b},Q_{c}$
\end_inset

.
 The representation of the state of the quantum system becomes:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\Ket{Q_{x}}=x_{1}\left[\begin{array}{c}
1\\
0
\end{array}\right]+x_{2}\left[\begin{array}{c}
0\\
1
\end{array}\right]=\left[\begin{array}{c}
x_{1}\\
x_{2}
\end{array}\right]\;x\in\left\{ a,b,c\right\} 
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\Ket{Q_{ab}}=\Ket{Q_{a}}\otimes\Ket{Q_{b}}=\begin{bmatrix}a_{1}\begin{bmatrix}b_{1}\\
b_{2}
\end{bmatrix}\\
a_{2}\begin{bmatrix}b_{1}\\
b_{2}
\end{bmatrix}
\end{bmatrix}=\begin{bmatrix}a_{1}b_{1}\\
a_{1}b_{2}\\
a_{2}b_{1}\\
a_{2}b_{2}
\end{bmatrix}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\Ket{Q_{ab}}=\begin{bmatrix}a_{1}b_{1}\\
a_{1}b_{2}\\
a_{2}b_{1}\\
a_{2}b_{2}
\end{bmatrix}=a_{1}b_{1}(\Ket{0}\otimes\Ket{0})+a_{1}b_{2}(\Ket{0}\otimes\Ket{1})+a_{2}b_{1}(\Ket{1}\otimes\Ket{0})+a_{2}b_{2}(\Ket{1}\otimes\Ket{1})
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\Ket{Q_{abc}}=\Ket{Q_{a}}\otimes\Ket{Q_{b}}\otimes\Ket{Q_{c}}=\Ket{Q_{ab}}\otimes\Ket{Q_{c}}=\begin{bmatrix}a_{1}b_{1}\begin{bmatrix}c_{1}\\
c_{2}
\end{bmatrix}\\
a_{1}b_{2}\begin{bmatrix}c_{1}\\
c_{2}
\end{bmatrix}\\
a_{2}b_{1}\begin{bmatrix}c_{1}\\
c_{2}
\end{bmatrix}\\
a_{2}b_{2}\begin{bmatrix}c_{1}\\
c_{2}
\end{bmatrix}
\end{bmatrix}=\begin{bmatrix}a_{1}b_{1}c_{1}\\
a_{1}b_{1}c_{2}\\
a_{1}b_{2}c_{1}\\
a_{1}b_{2}c_{2}\\
a_{2}b_{1}c_{1}\\
a_{2}b_{1}c_{2}\\
a_{2}b_{2}c_{1}\\
a_{2}b_{2}c_{2}
\end{bmatrix}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
In many cases it is impossible to consider 
\begin_inset Formula $Q_{a},Q_{b}$
\end_inset

and 
\begin_inset Formula $Q_{c}$
\end_inset

separately, because in a quantum system some quantum logic gates may cause
 to obtain a 
\begin_inset Quotes eld
\end_inset

mixed
\begin_inset Quotes erd
\end_inset

 state from which is not possible to find some suitable 
\begin_inset Formula $Q_{a},Q_{b}$
\end_inset

and 
\begin_inset Formula $Q_{c}$
\end_inset

 which satisfies (4).
 This concept, which is called 
\emph on
entanglement
\emph default
, will be described in detail later.
 The quadratic sum of all elements of a Ket must be 1, like said before
 for a single qubit.
\end_layout

\begin_layout Subsection
Quantum logic gates
\end_layout

\begin_layout Standard
In a quantum circuit model, quantum logic gates are transformation matrices
 which describes the behaviour of the physical quantum logic gates.
 Quantum logic gates are represented by means of unitary square matrices
 of size 
\begin_inset Formula $2^{n}$
\end_inset

,where 
\begin_inset Formula $n$
\end_inset

 is the number of qubits to which a gate can be applied.
 A matrix 
\begin_inset Formula $U$
\end_inset

 is said unitary if
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
UU^{\dagger}=U^{\dagger}U=I
\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $U^{\dagger}$
\end_inset

 is the Hermitian transpose of 
\begin_inset Formula $U$
\end_inset

.
 The Hermitian transpose can be obtained by transposing 
\begin_inset Formula $U$
\end_inset

 and then calculating the complex conjugate of all elements in 
\begin_inset Formula $U^{T}$
\end_inset

 matrix.
\end_layout

\begin_layout Standard
The description of the state obtained from the application of a generic
 quantum gate 
\begin_inset Formula $G$
\end_inset

from quantum state
\begin_inset Formula $\Ket{S^{0}}$
\end_inset

 can be calculated as:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Ket{S^{1}}=G\Ket{S^{0}}
\]

\end_inset


\end_layout

\begin_layout Standard
Some of the most known unitary logic gates are:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Symbol
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Matrix
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Circuit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hadamard
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\frac{1}{\sqrt{2}}\begin{bmatrix}1 & 1\\
1 & -1
\end{bmatrix}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Qcircuit @C=1em @R=.7em {& 
\backslash
gate{H} & 
\backslash
qw}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pauli-X (Not)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $X$
\end_inset

(or 
\begin_inset Formula $NOT$
\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[\begin{array}{cc}
0 & 1\\
1 & 0
\end{array}\right]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Qcircuit @C=1em @R=.7em {& 
\backslash
gate{X} & 
\backslash
qw}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pauli-Y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Y$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[\begin{array}{cc}
0 & -i\\
i & 0
\end{array}\right]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Qcircuit @C=1em @R=.7em {& 
\backslash
gate{Y} & 
\backslash
qw}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pauli-Z
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Z$
\end_inset

 or 
\begin_inset Formula $R_{\pi}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[\begin{array}{cc}
1 & 0\\
0 & -1
\end{array}\right]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Qcircuit @C=1em @R=.7em {& 
\backslash
gate{Z} & 
\backslash
qw}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Swap
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $SWAP$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[\begin{array}{cccc}
1 & 0 & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 0 & 1
\end{array}\right]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Qcircuit @C=1em @R=.7em {& 
\backslash
qswap & 
\backslash
qw  
\backslash

\backslash
 & 
\backslash
qswap & 
\backslash
qw}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Controlled Not
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $CNOT$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[\begin{array}{cccc}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 0 & 1\\
0 & 0 & 1 & 0
\end{array}\right]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Qcircuit @C=1em @R=.7em {& 
\backslash
ctrl{1} & 
\backslash
qw  
\backslash

\backslash
 & 
\backslash
targ & 
\backslash
qw}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Toffoli
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $CCNOT$
\end_inset

 or 
\begin_inset Formula $T$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[\begin{array}{cccccccc}
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\
0 & 0 & 0 & 0 & 0 & 0 & 1 & 0
\end{array}\right]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Qcircuit @C=1em @R=.7em {
\end_layout

\begin_layout Plain Layout

  & 
\backslash
ctrl{2} 
\backslash
qw & 
\backslash
qw 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  & 
\backslash
ctrl{1} 
\backslash
qw & 
\backslash
qw 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  & 
\backslash
targ        & 
\backslash
qw  
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $I$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[\begin{array}{cc}
1 & 0\\
0 & 1
\end{array}\right]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Qcircuit @C=1em @R=.7em {& 
\backslash
qw &}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Qcircuit @C=1em @R=.7em {& 
\backslash
gate{I} & 
\backslash
qw}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center
When applied to a single qubit in one of its bases (
\begin_inset Formula $\Ket{0}$
\end_inset

 or 
\begin_inset Formula $\Ket{1}$
\end_inset

), an H gate will put the qubit in a superstate.
\end_layout

\begin_layout Standard
There are many more controlled gates which are represented using a C prefix,
 like for the CNOT gate.
 Their structure is
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
U=\left[\begin{array}{cccc}
u_{11} & u_{12} & ... & u_{1m}\\
u_{21} & u_{22} & ... & u_{2m}\\
... & ... & ... & ...\\
u_{m1} & u_{m2} & ... & u_{mm}
\end{array}\right]\:CU=\left[\begin{array}{ccccc}
1 & 0 & 0 & ... & 0\\
0 & 1 & 0 & ... & 0\\
0 & 0 & u_{11} & ... & u_{1m}\\
... & ... & ... & ... & ...\\
0 & 0 & u_{m1} & ... & u_{mm}
\end{array}\right]
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

measurement
\begin_inset Quotes erd
\end_inset

 operator has symbol 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Qcircuit @C=1em @R=.7em {& 
\backslash
meter &}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Quantum circuits
\end_layout

\begin_layout Standard
Quantum circuits can be represented via a ladder-like scheme.
 Each row (horizontal lines) represents a distinct qubit, and the gates
 which have to be applied to the given qubit are inserted on that line,
 from left to right.
 Gates on the same column has to be applied at the same time.
\end_layout

\begin_layout Standard
Here's an example with a 2-qubit circuit:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{align*}
\backslash
Qcircuit @C=1em @R=.7em {
\end_layout

\begin_layout Plain Layout


\backslash
Ket{Q_0} & & 
\backslash
gate{H} & 
\backslash
gate{Z} & 
\backslash
gate{H} & 
\backslash
ctrl{1} & 
\backslash
gate{H}  & 
\backslash
qw & 
\backslash
meter 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
Ket{Q_1} & & 
\backslash
qw      & 
\backslash
gate{X} & 
\backslash
qw      & 
\backslash
targ    & 
\backslash
gate{H} & 
\backslash
qw & 
\backslash
meter
\end_layout

\begin_layout Plain Layout

}
\backslash
end{align*}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which is equivalent to the given circuit:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{align*}
\backslash
Qcircuit @C=1em @R=.7em {
\end_layout

\begin_layout Plain Layout


\backslash
Ket{Q_0} & & 
\backslash
gate{H} & 
\backslash
gate{Z} & 
\backslash
gate{H} & 
\backslash
ctrl{1} & 
\backslash
gate{H}  & 
\backslash
gate{I} & 
\backslash
meter 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
Ket{Q_1} & & 
\backslash
gate{I} & 
\backslash
gate{X} & 
\backslash
gate{I} & 
\backslash
targ    & 
\backslash
gate{H}  & 
\backslash
gate{I} & 
\backslash
meter
\end_layout

\begin_layout Plain Layout

}
\backslash
end{align*}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Identity gates columns will not change the state, they can be ignored, because
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
I_{n\,x\,n}\otimes I_{m\,x\,m}=I_{nm\,x\,nm}
\]

\end_inset


\end_layout

\begin_layout Standard
As said before, in a multi qubit computer, considering 
\begin_inset Formula $Q_{0}$
\end_inset

and 
\begin_inset Formula $Q_{1}$
\end_inset

as independent qubits would often lead to mistakes, because the application
 of a gate to a qubit would cause some side effects on other qubits.
\end_layout

\begin_layout Standard
If not specified, like in this case, every qubit is conventionally initialized
 to state 
\begin_inset Formula $\Ket{0}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Knowing that the above circuit is a 2-qubit circuit, the initial state 
\begin_inset Formula $\Ket{S^{0}}$
\end_inset

is described as 
\begin_inset Formula $\Ket{Q_{0}}\otimes\Ket{Q_{1}}=\Ket{00}$
\end_inset

 .
\end_layout

\begin_layout Standard
Then, the applied gate is 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
H\otimes I=\left[\begin{array}{cccc}
\frac{1}{\sqrt{2}} & 0 & \frac{1}{\sqrt{2}} & 0\\
0 & \frac{1}{\sqrt{2}} & 0 & \frac{1}{\sqrt{2}}\\
\frac{1}{\sqrt{2}} & 0 & -\frac{1}{\sqrt{2}} & 0\\
0 & \frac{1}{\sqrt{2}} & 0 & -\frac{1}{\sqrt{2}}
\end{array}\right]
\]

\end_inset

.
\end_layout

\begin_layout Standard
So, the state of the circuit after the application of 
\begin_inset Formula $H\otimes I$
\end_inset

 is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Ket{S^{1}}=(H\otimes I)\Ket{S^{0}}=\left[\begin{array}{cccc}
\frac{1}{\sqrt{2}} & 0 & \frac{1}{\sqrt{2}} & 0\\
0 & \frac{1}{\sqrt{2}} & 0 & \frac{1}{\sqrt{2}}\\
\frac{1}{\sqrt{2}} & 0 & -\frac{1}{\sqrt{2}} & 0\\
0 & \frac{1}{\sqrt{2}} & 0 & -\frac{1}{\sqrt{2}}
\end{array}\right]\left[\begin{array}{c}
1\\
0\\
0\\
0
\end{array}\right]=\left[\begin{array}{c}
\frac{1}{\sqrt{2}}\\
0\\
\frac{1}{\sqrt{2}}\\
0
\end{array}\right]=\frac{1}{\sqrt{2}}\Ket{00}+\frac{1}{\sqrt{2}}\Ket{10}
\]

\end_inset


\end_layout

\begin_layout Standard
Now, simulating the whole execution:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Ket{S^{2}}=(Z\otimes X)\Ket{S^{1}}=\left[\begin{array}{cccc}
0 & 1 & 0 & 0\\
1 & 0 & 0 & 0\\
0 & 0 & 0 & -1\\
0 & 0 & -1 & 0
\end{array}\right]\left[\begin{array}{c}
\frac{1}{\sqrt{2}}\\
0\\
\frac{1}{\sqrt{2}}\\
0
\end{array}\right]=\left[\begin{array}{c}
\frac{1}{\sqrt{2}}\\
0\\
0\\
-\frac{1}{\sqrt{2}}
\end{array}\right]
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Ket{S^{3}}=(H\otimes I)\Ket{S^{2}}=\left[\begin{array}{cccc}
\frac{1}{\sqrt{2}} & 0 & \frac{1}{\sqrt{2}} & 0\\
0 & \frac{1}{\sqrt{2}} & 0 & \frac{1}{\sqrt{2}}\\
\frac{1}{\sqrt{2}} & 0 & -\frac{1}{\sqrt{2}} & 0\\
0 & \frac{1}{\sqrt{2}} & 0 & -\frac{1}{\sqrt{2}}
\end{array}\right]\left[\begin{array}{c}
\frac{1}{\sqrt{2}}\\
0\\
0\\
-\frac{1}{\sqrt{2}}
\end{array}\right]=\left[\begin{array}{c}
\frac{1}{2}\\
-\frac{1}{2}\\
\frac{1}{2}\\
\frac{1}{2}
\end{array}\right]
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Ket{S^{4}}=CNOT\Ket{S^{3}}=\left[\begin{array}{cccc}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 0 & 1\\
0 & 0 & 1 & 0
\end{array}\right]\left[\begin{array}{c}
\frac{1}{2}\\
-\frac{1}{2}\\
\frac{1}{2}\\
\frac{1}{2}
\end{array}\right]=\left[\begin{array}{c}
\frac{1}{2}\\
-\frac{1}{2}\\
\frac{1}{2}\\
\frac{1}{2}
\end{array}\right]
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Ket{S^{5}}=(H\otimes H)\Ket{S^{4}}=\left[\begin{array}{cccc}
\frac{1}{2} & \frac{1}{2} & \frac{1}{2} & \frac{1}{2}\\
\frac{1}{2} & -\frac{1}{2} & \frac{1}{2} & -\frac{1}{2}\\
\frac{1}{2} & \frac{1}{2} & -\frac{1}{2} & -\frac{1}{2}\\
\frac{1}{2} & -\frac{1}{2} & -\frac{1}{2} & \frac{1}{2}
\end{array}\right]\left[\begin{array}{c}
\frac{1}{2}\\
-\frac{1}{2}\\
\frac{1}{2}\\
-\frac{1}{2}
\end{array}\right]=\left[\begin{array}{c}
0\\
1\\
0\\
0
\end{array}\right]
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Ket{S^{6}}=(I\otimes I)\Ket{S^{5}}=\Ket{S^{5}}=\left[\begin{array}{cccc}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 0 & 0 & 1
\end{array}\right]\left[\begin{array}{c}
0\\
1\\
0\\
0
\end{array}\right]=\left[\begin{array}{c}
0\\
1\\
0\\
0
\end{array}\right]
\]

\end_inset


\end_layout

\begin_layout Standard
Then, the measurement would show 
\begin_inset Formula $\Ket{01}$
\end_inset

as final result (
\begin_inset Formula $Q_{0}=0,Q_{1}=1$
\end_inset

).
\end_layout

\begin_layout Standard
By definition, all the quantum gates that have been applied to this circuit
 are unitary.
 For this, by replacing recursively 
\begin_inset Formula $S^{i},\:0<i<6$
\end_inset

 with 
\begin_inset Formula $S^{i-1}$
\end_inset

 in the example circuit we obtain:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Ket{S^{6}}=(I\otimes I)(H\otimes H)CNOT(H\otimes I)(Z\otimes X)(H\otimes I)\Ket{S^{0}}
\]

\end_inset


\end_layout

\begin_layout Standard
So, if the circuit is unitary, then we could reverse the execution from
 the final state to the initial one.
 This property is called reversibility.
 In the example:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
[(I\otimes I)(H\otimes H)CNOT(H\otimes I)(Z\otimes X)(H\otimes I)]^{-1}\Ket{S^{6}}=\Ket{S^{0}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
[(I\otimes I)(H\otimes H)CNOT(H\otimes I)(Z\otimes X)(H\otimes I)]^{\dagger}\Ket{S^{6}}=\Ket{S^{0}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Ket{S^{0}}=(H\otimes I){}^{\dagger}(Z\otimes X){}^{\dagger}(H\otimes I){}^{\dagger}CNOT{}^{\dagger}(H\otimes H){}^{\dagger}(I\otimes I){}^{\dagger}\Ket{S^{6}}
\]

\end_inset


\end_layout

\begin_layout Standard
In our example, there are no complex gates, so
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Ket{S^{0}}=(H\otimes I)'(Z\otimes X)'(H\otimes I)'CNOT'(H\otimes H)'(I\otimes I)'\Ket{S^{6}}
\]

\end_inset


\end_layout

\begin_layout Standard
All the applied matrices are symmetrical, so
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Ket{S^{0}}=(H\otimes I)(Z\otimes X)(H\otimes I)CNOT(H\otimes H)(I\otimes I)\Ket{S^{6}}
\]

\end_inset


\end_layout

\begin_layout Standard
This means that from every state of the system, we could rewind the execution
 flow.
 This property is called 
\emph on
reversible computing
\emph default
 and it is a property of every quantum computing algorithm.
 In this case, we can also build a circuit that from the final state 
\begin_inset Formula $S^{6}$
\end_inset

could reobtain the initial state 
\begin_inset Formula $S^{0}.$
\end_inset

 The circuit that allows to do that is the original circuit flipped horizontally
, that is:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{align*}
\backslash
Qcircuit @C=1em @R=.7em {
\end_layout

\begin_layout Plain Layout


\backslash
Ket{0} & &  
\backslash
gate{I} & 
\backslash
gate{H} & 
\backslash
ctrl{1} & 
\backslash
gate{H} & 
\backslash
gate{Z} & 
\backslash
gate{H} & 
\backslash
meter 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
Ket{1} & &  
\backslash
gate{I} & 
\backslash
gate{H} & 
\backslash
targ    & 
\backslash
gate{I} & 
\backslash
gate{X} & 
\backslash
gate{I} & 
\backslash
qw &
\backslash
meter
\end_layout

\begin_layout Plain Layout

}
\backslash
end{align*}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 3
Sometimes, considering qubits as independent from others would cause mistakes.
 Consider the following simple circuit:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{align*}
\backslash
Qcircuit @C=1em @R=.7em {
\end_layout

\begin_layout Plain Layout


\backslash
Ket{Q_0} & &  
\backslash
gate{H} & 
\backslash
gate{I} & 
\backslash
ctrl{1} & 
\backslash
meter 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
Ket{Q_1} & &  
\backslash
gate{H} & 
\backslash
gate{H} & 
\backslash
targ    & & 
\backslash
meter
\end_layout

\begin_layout Plain Layout

}
\backslash
end{align*}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Ket{S^{0}}=\Ket{00}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Ket{S^{1}}=H\otimes H\Ket{S^{0}}=\left[\begin{array}{cccc}
\frac{1}{2} & \frac{1}{2} & \frac{1}{2} & \frac{1}{2}\\
\frac{1}{2} & -\frac{1}{2} & \frac{1}{2} & -\frac{1}{2}\\
\frac{1}{2} & \frac{1}{2} & -\frac{1}{2} & -\frac{1}{2}\\
\frac{1}{2} & -\frac{1}{2} & -\frac{1}{2} & \frac{1}{2}
\end{array}\right]\left[\begin{array}{c}
1\\
0\\
0\\
0
\end{array}\right]=\left[\begin{array}{c}
\frac{1}{2}\\
\frac{1}{2}\\
\frac{1}{2}\\
\frac{1}{2}
\end{array}\right]
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Ket{S^{2}}=I\otimes H\Ket{S^{1}}=\left[\begin{array}{cccc}
\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} & 0 & 0\\
\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}} & 0 & 0\\
0 & 0 & \frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}}\\
0 & 0 & \frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
\end{array}\right]\left[\begin{array}{c}
\frac{1}{2}\\
\frac{1}{2}\\
\frac{1}{2}\\
\frac{1}{2}
\end{array}\right]=\left[\begin{array}{c}
\frac{1}{\sqrt{2}}\\
0\\
\frac{1}{\sqrt{2}}\\
0
\end{array}\right]=\frac{1}{\sqrt{2}}\Ket{00}+\frac{1}{\sqrt{2}}\Ket{10}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Ket{S^{3}}=CNOT\Ket{S^{2}}=\left[\begin{array}{cccc}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 0 & 1\\
0 & 0 & 1 & 0
\end{array}\right]\left[\begin{array}{c}
\frac{1}{\sqrt{2}}\\
0\\
\frac{1}{\sqrt{2}}\\
0
\end{array}\right]=\left[\begin{array}{c}
\frac{1}{\sqrt{2}}\\
0\\
0\\
\frac{1}{\sqrt{2}}
\end{array}\right]=\frac{1}{\sqrt{2}}\Ket{00}+\frac{1}{\sqrt{2}}\Ket{11}
\]

\end_inset


\end_layout

\begin_layout Standard
In state 
\begin_inset Formula $S^{3}$
\end_inset

, the two qubits are no more independent from eachother.
 In state 
\begin_inset Formula $S^{1}$
\end_inset

, both 
\begin_inset Formula $\Ket{Q_{0}}$
\end_inset

 and 
\begin_inset Formula $\Ket{Q_{1}}$
\end_inset

 are in state 
\begin_inset Formula $\frac{1}{\sqrt{2}}(\Ket{0}+\Ket{1})$
\end_inset

, then in 
\begin_inset Formula $S^{2}$
\end_inset

, 
\begin_inset Formula $\Ket{Q_{1}}=\Ket{0}$
\end_inset

and 
\begin_inset Formula $\Ket{Q_{0}}=\frac{1}{\sqrt{2}}(\Ket{0}+\Ket{1})$
\end_inset

.
 In 
\begin_inset Formula $S^{3}$
\end_inset

 it is nonsensical considering the two qubits individually.
 They can be both 0 or both 1 with equal probability.
 When two or more qubits are dependent on eachother, it is said that they
 are 
\emph on
entangled
\emph default
.
 If we measure 
\begin_inset Formula $Q_{0}$
\end_inset

 as first, its measurement will influence 
\begin_inset Formula $Q_{1}$
\end_inset

's measurement, because if and only if 
\begin_inset Formula $Q_{0}$
\end_inset

 collapses to 
\begin_inset Formula $\Ket{0}$
\end_inset

, then 
\begin_inset Formula $Q_{1}$
\end_inset

 will collapse to 
\begin_inset Formula $\Ket{0}$
\end_inset

.
 
\end_layout

\begin_layout Standard
In the
\emph on
 CHSH game
\emph default
 is proven that when one of two entangled quantum particles (which are modeled
 as qubits in circuits) is measured, the other particle will assume the
 same state that the first particle had assumed when collapsing, at a faster-tha
n-light speed.
\end_layout

\begin_layout Subsection
Tensor Network Diagrams
\end_layout

\begin_layout Standard
Tensor network diagrams are models used to better represent complex entangled
 circuits, because they allow to define circuits with less parameters.
 They are usually lossy data compression methods used for describing the
 most important properties of the quantum state of a system.
 Quantum circuits are submodels of tensor network diagrams.
\end_layout

\begin_layout Standard
A tensor is usually a box, oval or triangle with some wires pointing up
 and down.
 Wires pointing up are called arms, while wires pointing down are called
 legs.
 Arms are upper indices while legs are lower indices.
 The number of arms and legs determines the underlying algebraic structure
 (scalar, vector or matrix in our context).
 They are often tilted by 90 degrees clockwise.
 Vectors are single arm tensors, while matrices has one arm and one leg.
\end_layout

\begin_layout Standard
Disconnected tensors are multiplied using the tensor product (Kronecker
 product in our case).
 Tensors can be freely moved past eachother (plannar deformation) without
 changing the semantic of the content they model, as in the example:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{align*}
\backslash
Qcircuit @C=1em @R=.7em {
\end_layout

\begin_layout Plain Layout

&  
\backslash
gate{A} & 
\backslash
qw & 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

&  
\backslash
qw & 
\backslash
gate{B} &}
\end_layout

\begin_layout Plain Layout

=
\end_layout

\begin_layout Plain Layout


\backslash
Qcircuit @C=1em @R=.7em {
\end_layout

\begin_layout Plain Layout

&  
\backslash
gate{A} & 
\backslash
qw & 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

&  
\backslash
gate{B} & 
\backslash
qw &}
\end_layout

\begin_layout Plain Layout

=
\end_layout

\begin_layout Plain Layout


\backslash
Qcircuit @C=1em @R=.7em {
\end_layout

\begin_layout Plain Layout

&  
\backslash
gate{B} & 
\backslash
qw & 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

&  
\backslash
qw & 
\backslash
gate{A} &}
\end_layout

\begin_layout Plain Layout


\backslash
end{align*}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unlike quantum circuits, wires can cross tensor symbols and other wires
 as long as the wire endpoints do not change.
\end_layout

\begin_layout Standard
Two tensors connected together means that they are multiplied (contracted
 or summed over).
 The following image
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}     
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, shape=rectangle] (v0) at (0,0) {$Q_0$};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, shape=rectangle] (v1) at (1,0) {$H$};
\end_layout

\begin_layout Plain Layout


\backslash
node [coordinate] (end) [right of=v1, node distance=0.8cm]{};
\end_layout

\begin_layout Plain Layout


\backslash
draw (v0) -- node[above]{$i$} (v1) ;
\end_layout

\begin_layout Plain Layout


\backslash
draw  (v1) -- node[above]{$j$} (end) ;     
\backslash
end{tikzpicture} 
\end_layout

\begin_layout Plain Layout

= 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}     
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, shape=rectangle] (v0) at (0,0) {$S^1$};
\end_layout

\begin_layout Plain Layout


\backslash
node [coordinate] (end) [right of=v0, node distance=0.8cm]{};
\end_layout

\begin_layout Plain Layout


\backslash
draw  (v0) -- node[above]{$j$} (end) ;     
\backslash
end{tikzpicture} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Is equivalent to
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
S^{1}=Q_{0}H
\]

\end_inset


\end_layout

\begin_layout Standard
Tensor network diagrams were used in paper 
\emph on

\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Quantum Max-flow/Min-cut"
target "https://arxiv.org/abs/1508.04644"
literal "false"

\end_inset


\emph default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
A more complete and better explanation can be found in 
\emph on

\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Tensor Networks in a Nutshell"
target "https://arxiv.org/abs/1708.00006"
literal "false"

\end_inset


\begin_inset Quotes eld
\end_inset


\emph default
 paper.
\end_layout

\begin_layout Section
The classical algorithm
\end_layout

\begin_layout Standard
Classical maximum flow algorithms are based of the Ford-Fulkerson method
 via Edmonds-Karp algorithm and Dinic's algorithm.
\end_layout

\begin_layout Standard
A maximum flow algorithm is an algorithm which attempts to find a feasible
 flow which is maximum.
\end_layout

\begin_layout Subsection
Ford-Fulkerson method / Edmonds-Karp algorithm
\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "Ford Fulkerson method"
target "https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm"
literal "false"

\end_inset

requires as input:
\end_layout

\begin_layout Itemize
A network graph 
\begin_inset Formula $G(V,E)$
\end_inset

 where 
\begin_inset Formula $V$
\end_inset

 is the vertices set and 
\begin_inset Formula $E$
\end_inset

 is the edges set 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\forall(u,v)\in E:\exists f(u,v)$
\end_inset

 where 
\begin_inset Formula $f(u,v)$
\end_inset

 is the flow on the edge from vertex 
\begin_inset Formula $u$
\end_inset

 to vertex 
\begin_inset Formula $v$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\forall(u,v)\in E:\exists c(u,v)$
\end_inset

 where 
\begin_inset Formula $c(u,v)$
\end_inset

 is the available capacity of the edge from vertex 
\begin_inset Formula $u$
\end_inset

 to vertex 
\begin_inset Formula $v$
\end_inset


\end_layout

\begin_layout Itemize
A source node 
\begin_inset Formula $s\in V$
\end_inset

 and a sink node 
\begin_inset Formula $t\in V$
\end_inset


\end_layout

\begin_layout Itemize
Some constraints:
\end_layout

\begin_deeper
\begin_layout Itemize
Capacity constraints: 
\begin_inset Formula $\forall(u,v)\in E:f(u,v)\leq c(u,v)$
\end_inset


\end_layout

\begin_layout Itemize
Skew symmetry: 
\begin_inset Formula $\forall(u,v)\in E:f(u,v)=-f(v,u)$
\end_inset


\end_layout

\begin_layout Itemize
Flow conservation: 
\begin_inset Formula $\forall u\in V:\:u\ne s\:and\:u\ne t\implies\sum_{w\in V}f(u,w)=0$
\end_inset


\end_layout

\begin_layout Itemize
Source and sink flow constraint: 
\begin_inset Formula $\sum_{(s,u)\in E}f(s,u)=\sum_{(v,t)\in E}f(v,t)$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
A residual network graph 
\begin_inset Formula $G_{f}(V,E_{f})$
\end_inset

 with (residual) capacity 
\begin_inset Formula $c_{f}(u,v)=c(u,v)-f(u,v)$
\end_inset

 and no flow.
 A residual graph has some important properties.
 If 
\begin_inset Formula $f(u,v)>0$
\end_inset

 and 
\begin_inset Formula $c(v,u)=0$
\end_inset

, then 
\begin_inset Formula $c_{f}(v,u)=c(v,u)-f(u,v)=f(u,v)>0$
\end_inset

 , so a possible flow can be present in a residual graph but not in the
 original graph 
\begin_inset Formula $G$
\end_inset

 
\end_layout

\begin_layout Standard
Ford-Fulkerson method is composed of the following steps:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall(u,v)\in E:\:f(u,v)=0$
\end_inset


\end_layout

\begin_layout Enumerate
While there is a path 
\begin_inset Formula $P\subseteq E:P\ne\emptyset$
\end_inset

 from 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $t$
\end_inset

 in 
\begin_inset Formula $G_{f}$
\end_inset

with 
\begin_inset Formula $c_{f}(u,v)>0\;\forall(u,v)\in P$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Find 
\begin_inset Formula $c_{f}(P)=min\{c_{f}(u,v):(u,v)\in P\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall(u,v)\in P:$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $f(u,v)=f(u,v)+c_{f}(P)$
\end_inset

 (send the flow along the path)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $f(v,u)=f(v,u)-c_{f}(P)$
\end_inset

 (reduce the flow in the 
\begin_inset Quotes eld
\end_inset

reversed
\begin_inset Quotes erd
\end_inset

 path)
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
Step 2 looks for an augmenting path (by using a search algorithm), then
 step 2.a finds the maximum admissible flow correction that can be done in
 path P , then step 2.b updates the flows.
\end_layout

\begin_layout Standard
Edmond-Karps algorithm applies the Ford-Fulkerson method by implementing
 a breadth-first search to find the path in step 2.
 By using breadth first, the complexity of the algorithm is 
\begin_inset Formula $\mathcal{O}(VE^{2})$
\end_inset


\end_layout

\begin_layout Subsection
Dinitz's algorithm
\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "Dinitz's algorithm"
target "https://en.wikipedia.org/wiki/Dinic%27s_algorithm"
literal "false"

\end_inset

 (better known as Dinic's algorithm) is very similar to Edmond-Karps, it
 uses too a residual graph and looks for an augmenting path by using a level
 graph.
 A 
\emph on
level graph
\emph default
 is a graph that assigns to each vertex its distance to the root node.
 In some paper, it is called 
\emph on
layer graph
\emph default
.
\end_layout

\begin_layout Standard
Dinitz's algorithm steps are:
\end_layout

\begin_layout Enumerate
Building the residual graph
\end_layout

\begin_layout Enumerate
Building the layer graph from the residual graph, by discarding edges connecting
 vertices at the same level.
\end_layout

\begin_layout Enumerate
All the paths in the layer graph contain augmenting paths.
 If there are no paths, the flow is maximum.
\end_layout

\begin_layout Enumerate
Update the flows and the residual graph
\end_layout

\begin_layout Enumerate
Go to step 2
\end_layout

\begin_layout Section
Quantum Implementation
\end_layout

\begin_layout Standard
Before analyzing the proposed quantum implementations, there are some important
 details that has to be described about the actual state of the art of quantum
 computers.
\end_layout

\begin_layout Standard
For what regards the chosen quantum algorithm, I have considered many options.
 The most important specification that I have considered is that the quantum
 max flow algorithm implementation must work on a generic directed weighted
 graph, because classical computers can still provide excellent results
 for more specific cases.
\end_layout

\begin_layout Subsection
Quantum Computers
\end_layout

\begin_layout Standard
Quantum computers at the actual state of the technology cannot provide a
 memory or either a 
\begin_inset Quotes eld
\end_inset

qRAM
\begin_inset Quotes erd
\end_inset

, because there is no way to reproduce an arbitrary unknown state (no cloning
 theorem) and there is no known way to store and load qubits (at least,
 
\begin_inset CommandInset href
LatexCommand href
name "not confirmed from reliable sources"
target "https://www.nextbigfuture.com/2018/12/ionq-has-the-most-powerful-quantum-computers-with-79-trapped-ion-qubits-and-160-stored-qubits.html"
literal "false"

\end_inset

).
 All the qubits has to be allocated at the beginning of the computation
 and there is no 
\begin_inset Quotes eld
\end_inset

discard
\begin_inset Quotes erd
\end_inset

 option for a qubit.
\end_layout

\begin_layout Standard
At the moment, the most powerful quantum computer has more or less 70 qubits
 available (
\begin_inset CommandInset href
LatexCommand href
name "Google Bristlecone"
target "https://ai.googleblog.com/2018/03/a-preview-of-bristlecone-googles-new.html"
literal "false"

\end_inset

)
\end_layout

\begin_layout Standard
The whole circuit has to be available at compile time, and there is a unique
 flow of execution.
 Measurement cannot be used to change the behaviour of the quantum system
 at runtime.
 
\end_layout

\begin_layout Standard
Quantum states are very unstable, so this makes the process of creating
 a qRAM even more complex.
\end_layout

\begin_layout Standard
From a programmer's point of view, a quantum computer programming is very
 similar to FPGA programming.
\end_layout

\begin_layout Standard
Quantum computers have a structure very similar to vector machines and GPUs,
 but without any buffer or memory.
 For this reason, they have been successfully applied in 
\begin_inset CommandInset href
LatexCommand href
name "neural networks"
target "https://ai.googleblog.com/2018/12/exploring-quantum-neural-networks.html"
literal "false"

\end_inset

, an application where GPUs excels at.
\end_layout

\begin_layout Standard
Quantum computers provides a probabilistic result, circuits are run many
 times and can be used for critical systems only if their results can be
 checked by classical computers or other more reliable methods.
\end_layout

\begin_layout Standard
Quantum gates has a reliability percentage, for this reason long circuits
 tend to fail in producing correct results.
\end_layout

\begin_layout Standard
In most quantum computers, not all qubits lines are interconnected.
 Most qubits are interconnected with 2 or more other qubits.
\end_layout

\begin_layout Subsection
Tensor Networks
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Quantum Max-flow/Min-cut"
target "https://arxiv.org/abs/1508.04644"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

 paper proposed to represent flow graphs as tensor networks, where the capacity
 of each link in the flow network is represented as the dimension of a Hilbert
 space.
 This implementation looked very complex, and also relies on qudits (quantum
 digits), not qubits, so the required size of the circuit for representing
 a simple graph could explode.
\end_layout

\begin_layout Standard
Also, the paper does not provide an implementation of the actual circuit,
 which led me to look for other options.
\end_layout

\begin_layout Subsection
Quantum Edmond-Karps Algorithm
\end_layout

\begin_layout Standard
The proposed paper 
\begin_inset Quotes eld
\end_inset

 
\begin_inset CommandInset href
LatexCommand href
name "Quantum Algorithm Implementations for Beginners "
target "https://arxiv.org/abs/1804.03719"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

 shows an approach for building a quantum max flow algorithm, which is better
 explained in the paper 
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Quantum Algorithms for Matching and Network Flows"
target "https://arxiv.org/abs/quant-ph/0508205"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

.
 They propose to build a layered subgraph (also called level subgraph, the
 same that is used in Dinitz's algorithm).
 This is the version that iI have implemented.
 The procedure is:
\end_layout

\begin_layout Enumerate
Set the level 
\begin_inset Formula $l$
\end_inset

 to 
\begin_inset Formula $\infty$
\end_inset

 to all nodes except the source 
\begin_inset Formula $s$
\end_inset

, whose level is set to 0.
\end_layout

\begin_layout Enumerate
Create a one entry queue 
\begin_inset Formula $Q=$
\end_inset

{
\begin_inset Formula $s$
\end_inset

}
\end_layout

\begin_layout Enumerate
While 
\begin_inset Formula $Q\neq\emptyset$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Take the first node 
\begin_inset Formula $n$
\end_inset

 from 
\begin_inset Formula $Q$
\end_inset


\end_layout

\begin_layout Enumerate
Find by Grovers search all its neighbors 
\begin_inset Formula $y$
\end_inset

 with 
\begin_inset Formula $l(y)=\infty$
\end_inset

, set 
\begin_inset Formula $l(y)=l(n)+1$
\end_inset

, and append 
\begin_inset Formula $y$
\end_inset

 into 
\begin_inset Formula $Q$
\end_inset


\end_layout

\begin_layout Enumerate
Remove 
\begin_inset Formula $n$
\end_inset

 from 
\begin_inset Formula $Q$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
But there is a problem with this algorithm, at step 3.b.
 It can become clear after Grover's algorithm is being explained.
\end_layout

\begin_layout Subsubsection
Grover's Algorithm
\end_layout

\begin_layout Standard
Before defining what does Grover's Algorithm, it is necessary defining what
 is a quantum oracle.
\end_layout

\begin_layout Standard
A 
\emph on
quantum oracle
\emph default
 of a function 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $f(C)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 is a quantum circuit which given an input 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $S$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
, it outputs 
\begin_inset Formula $\Ket{1}$
\end_inset

 on a specific qubit if 
\begin_inset Formula $S\in f(C)$
\end_inset

, 
\begin_inset Formula $\Ket{0}$
\end_inset

otherwise.
 Grover's algorithm has complexity 
\begin_inset Formula $O({\sqrt{N}})$
\end_inset

 times the oracle complexity.
\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "Grover's Algorithm"
target "https://en.wikipedia.org/wiki/Grover's_algorithm#/"
literal "false"

\end_inset

 (sometimes called Grover's search algorithm) is a quantum algorithm which,
 given as input a oracle of 
\begin_inset Formula $f(C)$
\end_inset

 and the expected output of the function 
\begin_inset Formula $S$
\end_inset

, it attempts to find an input 
\begin_inset Formula $C\in f^{-1}(S)$
\end_inset

 which could have generated 
\begin_inset Formula $S$
\end_inset

.
 This has some important consequences in cryptography, because many algorithms
 for cryptography could possibly be broken if a quantum representation of
 the cryptographic one way function is provided.
 
\end_layout

\begin_layout Standard
Originally, Grover's algorithm was called Grover's search, because it allows
 to do a search in an unsorted database of possible inputs.
 But knowing that building (classically) such a oracle for a unsorted database
 requires at least linear complexity, it is not suggested to be used practically
 for searches.
 This is the main reason which blocks the provided quantum algorithm to
 outcome the classical one.
\end_layout

\begin_layout Standard
Grover's algorithm outputs one result per run.
 It could be scaled both horizontally (another quantum computer running
 the same circuit) and vertically (double the quantum circuit, like in a
 distinct quantum computer).
 
\end_layout

\begin_layout Standard
Grover's circuit is composed of four parts, superposition initialization,
 oracle, phase shift and diffusion.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{align*}
\backslash
Qcircuit @C=1em @R=0em { 
\end_layout

\begin_layout Plain Layout

&
\backslash
multigate{2}{
\backslash
mathcal{H}}&
\backslash
qw&
\backslash
multigate{2}{Oracle}& 
\backslash
qw & 
\backslash
qw & 
\backslash
multigate{2}{
\backslash
mathcal{H}}&
\backslash
qw &
\backslash
multigate{2}{Phase
\backslash
:shift}& 
\backslash
qw & 
\backslash
multigate{2}{
\backslash
mathcal{H}}&
\backslash
qw    
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

&
\backslash
ghost{
\backslash
mathcal{H}}&       
\backslash
qw&
\backslash
ghost{Oracle}& 
\backslash
qw & 
\backslash
qw & 
\backslash
ghost{
\backslash
mathcal{H}}& 
\backslash
qw& 
\backslash
ghost{Phase
\backslash
:shift}& 
\backslash
qw & 
\backslash
ghost{
\backslash
mathcal{H}}& 
\backslash
qw     
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

&
\backslash
ghost{
\backslash
mathcal{H}}&       
\backslash
qw&
\backslash
ghost{Oracle}& 
\backslash
qw & 
\backslash
qw & 
\backslash
ghost{
\backslash
mathcal{H}}& 
\backslash
qw& 
\backslash
ghost{Phase
\backslash
:shift}& 
\backslash
qw& 
\backslash
ghost{
\backslash
mathcal{H}}& 
\backslash
qw     
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

& 
\backslash
dstick{superposition}
\backslash
cwx[-1] &&&&&&& 
\backslash
dstick{diffusion}
\backslash
cwx[-1] 
\backslash
gategroup{1}{7}{3}{11}{.7em}{--}
\end_layout

\begin_layout Plain Layout

} 
\backslash
end{align*}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
:
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Of those parts, the oracle and the diffusion part are iterated many times.
 The number of times that they have to be repeated has to be set as 
\begin_inset Formula $\frac{\pi}{4}\sqrt{2^{n}}$
\end_inset

, where 
\begin_inset Formula $n$
\end_inset

 is the number of qubits used ( 
\begin_inset Formula $2^{n}$
\end_inset

is the size of the 
\begin_inset Quotes eld
\end_inset

database
\begin_inset Quotes erd
\end_inset

).
 The problem is that 
\begin_inset Formula $\frac{\pi}{4}\sqrt{2^{n}}$
\end_inset

 is often not an integer.
 Rounding the number of iterations could cause to not find a solution even
 when it exists.
\end_layout

\begin_layout Quote
\align center
Grovers quantum searching technique is like cooking a souffl.
 You put the state obtained by quantum parallelism in a quantum oven and
 let the desired answer rise slowly.
 Success is almost guaranteed if you open the oven at just the right time.
 But the souffl is very likely to fallthe amplitude of the correct answer
 drops to zeroif you open the oven too early.  Kristen Fuchs
\end_layout

\begin_layout Subsubsection
Finding neighbors by Grover's algorithm
\end_layout

\begin_layout Quote
3.b) Find by Grovers search all its neighbors 
\begin_inset Formula $y$
\end_inset

 with 
\begin_inset Formula $l(y)=\infty$
\end_inset

, set 
\begin_inset Formula $l(y)=l(n)+1$
\end_inset

, and append 
\begin_inset Formula $y$
\end_inset

 into 
\begin_inset Formula $Q$
\end_inset


\end_layout

\begin_layout Standard
This is the key point.
 Grover's algorithm for searches returns one result per run, which is chosen
 casually between all the possible results.
 Finding all the infinite-distanced neighbors of a single node is a task
 that can be done in 
\begin_inset Formula $O(\frac{\pi}{4}\sqrt{2^{\left\lceil \log_{2}\bar{b}\right\rceil }}\bar{b})\implies O(\bar{b}\sqrt{\bar{b}})$
\end_inset

, where 
\begin_inset Formula $\bar{b}$
\end_inset

 is the average number of neighbors in the graph (
\begin_inset Quotes eld
\end_inset

branching factor
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
The explanation behind 
\begin_inset Formula $O(\frac{\pi}{4}\sqrt{2^{\left\lceil \log_{2}\bar{b}\right\rceil }}\bar{b})$
\end_inset

 lies in the fact that the algorithm has to be rerun at least 
\begin_inset Formula $\bar{b}$
\end_inset

 (neighboring nodes) time to find all infinite distance neighbors, and each
 run has to do 
\begin_inset Formula $\frac{\pi}{4}\sqrt{2^{\left\lceil \log_{2}\bar{b}\right\rceil }}$
\end_inset

 iterations, where 
\begin_inset Formula $2^{\left\lceil \log_{2}\bar{b}\right\rceil }$
\end_inset

 is the size of the database (
\begin_inset Quotes eld
\end_inset

search space
\begin_inset Quotes erd
\end_inset

).
 The number of database entries has to be a power of 2.
 The assumption behind this estimation is that the best 
\begin_inset Quotes eld
\end_inset

lucky
\begin_inset Quotes erd
\end_inset

 case is considered, no quantum errors are considered.
\end_layout

\begin_layout Standard
The overall quantum complexity is then 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
O(\bar{b}^{\frac{3}{2}}N)
\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $N$
\end_inset

is the number of nodes in the graph.
 This complexity can be reduced heavily depending on the topology of the
 network.
 Considering the average branching factor as 
\begin_inset Formula $\bar{b}=\frac{E}{N}$
\end_inset

 where 
\begin_inset Formula $E$
\end_inset

 is the number of edges in the network flow graph, we get:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
O(\frac{E^{\frac{3}{2}}}{\sqrt{N}})
\]

\end_inset


\end_layout

\begin_layout Standard
This complexity has to be multiplied with the complexity of the oracle.
 A boolean oracle (the only one which could work in a general network flow
 graph) has almost constant complexity.
 The problem is that the oracle has to be built classically.
 This can be done in 
\begin_inset Formula $O(\bar{b})=O(\frac{E}{N})$
\end_inset

.
 Unfortunately, when a node is found, a layer is assigned to it, the database
 changes and so the oracle has to be changed (recomputed classically) too.
 Each element can be found at most once (once it is found, it gets its layer
 number updated), so the overall complexity (both classical and quantum)
 is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
O(\frac{E^{\frac{3}{2}}}{\sqrt{N}}\cdot\frac{E}{N}\cdot N)=O(\frac{E^{\frac{5}{2}}}{\sqrt{N}})
\]

\end_inset


\end_layout

\begin_layout Standard
This result is still optimistic, because there is a strong assumption behind
 this estimation.
 Quantum errors happens very often, especially in large sparse search spaces.
 This is due to the intrinsic nature of quantum computers and it is due
 to the problem of having many values to be searched.
 Quantum errors happen because the probability of some values which shouldn't
 be found is not exactly zero, and tend to increase as the size of the search
 space increases.
 
\end_layout

\begin_layout Standard
Suppose that we have a dataset of 200 elements where 50 elements are being
 searched.
 Then, we would have an 8 qubit quantum circuit in which 56 entries are
 out of bound, 100 elements have 1% each chance to be extracted and 100
 elements shouldn't be found.
 Noise in a quantum algorithm can increase exponentially the chances to
 outcome erroroneous values, also because each iteration in Grover's algorithm
 amplifies the most significant possible outcomes, which could be an erroneous
 one (noise).
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\]

\end_inset


\end_layout

\begin_layout Standard
The complexity considered in the paper 
\begin_inset Quotes eld
\end_inset


\emph on

\begin_inset CommandInset href
LatexCommand href
name "Quantum Algorithms for Matching and Network Flows"
target "https://arxiv.org/abs/quant-ph/0508205"
literal "false"

\end_inset


\emph default

\begin_inset Quotes erd
\end_inset

 is based on an 
\begin_inset Quotes eld
\end_inset

adjacency model
\begin_inset Quotes erd
\end_inset

.
 The adjacency model I suppose is based on an adjacency matrix, which could
 used to store information about the network.
 
\end_layout

\begin_layout Standard
Implementing such a matrix in a quantum circuit would cause to have huge
 circuits.
 Let's start by a graph without network capacities.
 Then we would have a circuit with a size of 
\begin_inset Formula $N^{2}$
\end_inset

 qubits.
 Actually, this would be unfeasible for most networks due to the fact that
 the most powerful quantum computer can work on at most 100 qubits.
\end_layout

\begin_layout Subsubsection
Building the oracle
\end_layout

\begin_layout Standard
Building the oracle requires to know where the elements are in the classical
 dataset.
 This means that to know where they are, a linear search (if the set is
 unordered) has to be performed.
 Once the elements have been found, it is nonsensical insert them into an
 oracle and then let the quantum algorithm find the values that have been
 inserted in the oracle, because we still know what we have to search.
 It could have sense only for testing how a quantum computer behaves, so
 this is the reason why I have kept writing the implementation.
 
\end_layout

\begin_layout Subsection
Actual implementation
\end_layout

\begin_layout Standard
The actual implementation sticks as most as possible to the quantum Edmond-Karps
 Algorithm version.
 It uses Grover's algorithm to find neighbors whose distance is infinite.
 Neighbors are represented as indices, which has to be found in the implicit
 database.
 An
\emph on
 implicit database 
\emph default
is a database in which all the possible elements are present.
 The elements which has to be found are marked.
 Non-marked elements should never be outcomed.
\end_layout

\begin_layout Standard
To improve slightly the algorithm's performance, the algorithm stops layering
 the graph once the sink is found.
 It also excludes the nodes whose flow cannot be increased from the layering
 phase.
\end_layout

\begin_layout Standard
Then, from the sink, the path is rewinded to the source (it is a spanning
 tree) and then the flow is augmented on the path.
 The algorithm stops when the layered graph cannot include the sink.
\end_layout

\begin_layout Standard
It also includes a random graph generator for generating samples.
 To provide a graphical output of the result, the graph is being outputted
 as .dot and .gexf.
 The README.md file contains the technical details for building and testing
 the program.
 
\end_layout

\begin_layout Standard
On Linux, a .png file is also generated from the .dot.
\end_layout

\begin_layout Paragraph*
Project structure
\end_layout

\begin_layout Standard
The project is composed of 3 C# files, a .csproj configuration XML file and
 a Q# file, that is the Microsoft Quantum's 
\begin_inset CommandInset href
LatexCommand href
name "Grover Algorithm implementation"
target "https://github.com/microsoft/Quantum/blob/master/Samples/src/DatabaseSearch/DatabaseSearch.qs"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

main
\begin_inset Quotes erd
\end_inset

 C# file is Driver.cs, which contains two classes, Utilities and Driver.
\end_layout

\begin_layout Standard
Utilities contains code for generating a graph schema, while Driver contains
 the main function and the code that calls the quantum Edmonds-Karp algorithm.
\end_layout

\begin_layout Standard
Graph.cs contains the code for generating and handling graphs.
 It has 3 classes, Edge, Graph and Node.
\end_layout

\begin_layout Standard
Graph.addLayer is the layering function, while Graph.findInnerPath is the
 recursive function that looks for an augmenting path.
 The quantum function is Graph.findLayerNeighbors, which is used both to
 find infinite distanced neighbors (infinite value is stored as -1) and
 to find the augmenting path.
\end_layout

\begin_layout Subsection
Other attempts
\end_layout

\begin_layout Standard
I have thought about algorithms which could exploit at most as possible
 the quantum potential, instead of 
\begin_inset Quotes eld
\end_inset

porting
\begin_inset Quotes erd
\end_inset

 classical algorithms to quantum.
 The first critical problems which arised were:
\end_layout

\begin_layout Enumerate
How to represent graphs? 
\end_layout

\begin_layout Enumerate
How to represent weights?
\end_layout

\begin_layout Paragraph*
How to represent graphs
\end_layout

\begin_layout Standard
I tried to find a smart way to represent graphs in quantum circuits.
 I have taken ispiration from the paper 
\emph on

\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Quantum Max-flow/Min-cut"
target "https://arxiv.org/abs/1508.04644"
literal "false"

\end_inset


\emph default

\begin_inset Quotes erd
\end_inset

 in which tries to represent a graph as a tensor network.
 Knowing that quantum circuits are submodels of tensor networks, I attempted
 to represent a simple tree architecture (without weights) in the circuit.
 I used qubits as nodes and entanglement to represent edges between nodes.
 I accomplished in representing a single simple path without repeating nodes
 (trivial problem), which would have been either taken or not taken, but
 I failed in representing more complex structures, due to the fact that
 i haven't been able to entangle 3 qubits together.
 This attempt seemd promising to me because with entanglement i would have
 obtained the flow constraint, so that if a node is 
\begin_inset Quotes eld
\end_inset

taken
\begin_inset Quotes erd
\end_inset

, then another following node should be taken too.
 If we consider for example the state 
\begin_inset Formula $\frac{1}{\sqrt{2}}(\Ket{00}+\Ket{11})$
\end_inset

, if the first qubit is taken, then the following one would be taken too
 or none of those would be taken.
\end_layout

\begin_layout Paragraph
How to represent weights
\end_layout

\begin_layout Standard
In the upper representation there is no weight representation.
 Weights are hard to be represented in a quantum environment, especially
 because comparisons in quantum circuits (eg toffoli) are hard to implement
 and cause an explosion in size of the circuit.
 What I have considered is to represent only the layer graph built on the
 residual graph in the quantum circuit.
 Then, I would have used the quantum circuit to find a path in the classical
 residual graph to obtain a (small) speedup.
 
\end_layout

\begin_layout Section
Programming environment
\end_layout

\begin_layout Standard
The chosen programming enviroment is Microsoft Quantum Development Kit (QDK)
 on Visual Studio Code.
\end_layout

\begin_layout Standard
Visual Studio Code is one of the 
\begin_inset CommandInset href
LatexCommand href
name "most popular development environments"
target "https://insights.stackoverflow.com/survey/2018#development-environments-and-tools"
literal "false"

\end_inset

, due to its simple design.
 It is composed of a simple but powerful lightweight editor, with many extension
s available for download.
 This allows the developer to install packages as soon as they are required,
 which is a great advantage.
 It offers an intuitive UI similar to Atom IDE but much lighter and reactive.
 s
\end_layout

\begin_layout Standard
The QDK is still under development, it is updated with a new version almost
 monthly but updates often brake older versions code.
 It is based on Microsoft .Net and it is cross-platform.
\end_layout

\begin_layout Standard
QDK is documented, but the documentation is sparse in many Microsoft websites,
 and not all articles are updated.
 Anyway, the Microsoft Quantum team is always available on Github and updates
 the outdated documentation as soon as they have been notified of.
\end_layout

\begin_layout Standard
QDK uses C# for the classical parts and Q# (which is similar to F# and C#)
 for the quantum parts.
\end_layout

\begin_layout Standard
There are also many Microsoft based examples/libraries, such as an Grover's
 Algorithm implementation.
\end_layout

\begin_layout Standard
There are also some Q# community integrations which allow to integrate the
 Q# code to other quantum languages, such as Qiskit and OpenQasm.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "Tensor Networks In A Nutshell"
key "https://arxiv.org/abs/1708.00006"
literal "false"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "Explorations in Quantum Computing"
key "Explorations in Quantum Computing second edition, Colin P. Williams"
literal "false"

\end_inset


\end_layout

\end_body
\end_document
